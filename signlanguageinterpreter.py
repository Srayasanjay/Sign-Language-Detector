# -*- coding: utf-8 -*-
"""SignLanguageInterpreter.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1b9UD_1q6JEUt9lb6G4hLaFsUNoChUbVi
"""

!pip install mediapipe opencv-python tensorflow flask
!pip install joblib

import os
import cv2
import numpy as np
import mediapipe as mp
import joblib
from tensorflow.keras.models import load_model

# Load the pre-trained model and label encoder
model = load_model('sign_language_model.h5')
label_encoder = joblib.load('label_encoder.pkl')

# Initialize MediaPipe Hands
mp_hands = mp.solutions.hands
hands = mp_hands.Hands()
mp_drawing = mp.solutions.drawing_utils

def process_frame(frame):
    frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    result = hands.process(frame_rgb)
    if result.multi_hand_landmarks:
        landmarks = result.multi_hand_landmarks[0].landmark
        landmarks = np.array([[lm.x, lm.y, lm.z] for lm in landmarks]).flatten()
        landmarks = np.expand_dims(landmarks, axis=0)

        prediction = model.predict(landmarks)
        sign = label_encoder.inverse_transform([np.argmax(prediction)])[0]

        cv2.putText(frame, sign, (10, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)

        for hand_landmarks in result.multi_hand_landmarks:
            mp_drawing.draw_landmarks(frame, hand_landmarks, mp_hands.HAND_CONNECTIONS)
    return frame

cap = cv2.VideoCapture(0)  # Open the default camera
while cap.isOpened():
    ret, frame = cap.read()  # Read a frame from the camera
    if not ret:
        break  # If the frame was not read correctly, exit the loop
    frame = process_frame(frame)  # Process the frame for hand tracking and sign prediction
    cv2.imshow('Hand Tracking and Sign Prediction', frame)  # Display the frame

    if cv2.waitKey(1) & 0xFF == ord('q'):  # Check if the 'q' key is pressed
        break  # Exit the loop

cap.release()  # Release the camera resource
cv2.destroyAllWindows()  # Close all OpenCV windows

import os

# List files in the current directory
print(os.listdir())



